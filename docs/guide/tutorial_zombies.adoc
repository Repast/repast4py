== Tutorial 3 - The Zombies Model

In <<_tutorial_1_a_simple_random_walk_model,Tutorial 1>>, we developed a simple model in which agents walk at random around a 2-dimensional Cartesian grid. The Zombies Model builds on this simple movement implementation, adding an additional agent type and using a Continuous Space. 

*This text assumes you have already read the _Repast4Py Users Guide_ up through <<_tutorial_1_a_simple_random_walk_model,Tutorial 1>>.*

In the Zombies model, human agents are pursued by zombie agents, and once caught become zombies themselves. Each timestep, the following occurs:

. All the Zombies:
  .. Query their immediate neighborhood to determine the adjacent grid location with
the most number of Humans
  .. Move towards that location, assuming any Humans are found
  .. Infect the Humans at that location, also assuming any Humans are found
. All the Humans:
  .. Become a Zombie, after being infected for more than 9 timesteps, else
  .. Query their immediate neighborhood to determine the adjacent grid location with
the fewest number of Zombies
  .. Move to that location at twice the speed of a Zombie.

See the {website}/examples/examples.html[Repast4Py Examples] page to download the source code for this model 
and for more information on getting started with the examples.

The code consists of the following components:

* Two agent classes: a <<The Zombie Agent, Zombie class>> that implements the behavior of the zombie agents, and a <<The Human Agent, Human class>> that implements the state and behavior of the human agents.
* <<Restoring the Agents, A restore function>> that creates both Zombie and Human agents when they are moved from one MPI rank to another.
* A <<The Model class, Model class>> responsible for initializing and managing the simulation and
simulation components, including:
** the model's <<Scheduling Events and Creating the Context, context>>
** <<Implementing Spatial Projections, Continuous Space and Discrete Grid>> projections, 
** <<Scheduled methods, Scheduled Events>>, and
** <<Logging,Logging>>
* A <<_the_grid_neighbor_finder, GridNghFinder>> class for quickly computing neighboring grid locations using
numpy and the the https://numba.pydata.org[Numba] Python package to accelerate the computation
* The standard `run` function that creates and starts the simulation.
* The standard `if __name__ == "__main__"` block in which input parameters are parsed and
allows the simulation to be run from the command line.

NOTE: The Model class instance `model` is a global variable defined as an attribute of the
zombies module itself. Consequenly, it is available to all the code in `zombies.py` as just
`model`, that is, you will see it referenced as `model` rather than `self.model` or as a 
function argument. The Model class contains references to the discrete grid and continuous space
projections as well as the grid neighborhood finder. These are used by the agents
in the implemenation of their behavior. By making `model` a global variable, our
agents can conveniently access these required components.


=== The Agent Classes

The Zombies model implements two agent classes: a `Zombie` and a `Human`. The zombie's behavior
is to pursue humans across a two dimensional Cartesian space and infect them. The human's behavior
is to flee from zombies. Humans contain a boolean (`infected`) field indicating whether or not they are infected, and an integer (`infected_duration`) field tracking the duration of the infection. When that
value reaches 10, that human is replaced with a zombie. The methods that implement infection, and 
the transition from human to zombie are described in <<The Zombie step() Method,the Zombie step method>>, the <<The Human step() Method,the Human step method>>, and <<Step,the Model class scheduled step method>>. 

Both agents inhabit two two-dimensional projections:
a {website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[`SharedGrid`] and a
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[`SharedCSpace`]. The
first of these is a matrix type grid where the agent locations are expressible
as discrete integer coordinates. The second is a continuous space where the agent locations
are expressible as continuous floating point coordinates. The grid is used to implement agent
vision. Humans and zombies can _see_ the zombies and humans in the grid locations
that neighbor their own, and act accordingly. The continuous space is used for movement, and
unlike the `Walker` agents in <<_tutorial_1_a_simple_random_walk_model, Tutorial 1>> which move a single
grid unit at a time, the human and zombie agents move in fractions of a grid unit, 
0.25 for zombies, and 0.5 grid units for humans. In this way, the humans are twice as fast as
the zombies. When a human or zombie moves in the continuous space, a method in the
`Model` class updates its location in the grid space. These spatial aspects are described in
detail in the <<Implementing Spatial Projections>> subsection.
 
==== The Zombie Agent

We implement our Zombie agent using the `Zombie` class. As required for all Repast4Py agent implementations, the `Zombie` class extends
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`], passing it the components of the unique agent id tuple.

[source,python,numbered]
----
from repast4py import core

...

class Zombie(core.Agent): #<1>

    TYPE = 1 #<2>

    def __init__(self, a_id, rank): #<3>
        super().__init__(id=a_id, type=Zombie.TYPE, rank=rank)

    ...
----
<1> `Zombie` subclasses `repast4py.core.Agent`. Subclassing `Agent` is a requirement for all Repast4Py agent implementations.
<2> `TYPE` is a class variable that defines the agent type id for the Zombie agents. This is a required part of the unique agent id tuple. 
<3> In order to uniquely identify the agent across all ranks in the simulation, the
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`] constructor takes the following three arguments: an integer id that uniquely identifies an agent on the process where it was created, a non-negative integer identifying the type of the agent, and the rank on which the agent is created.

===== The Zombie step() Method
The zombie agent behavior is implemented in its `step` method. Here, the zombie queries its immediate neighborhood to find the location with the most humans. Assuming some humans are found, the zombie will then move towards that grid location. If multiple grid locations have the maximum number of humans, including when the maximum is 0, the zombie will choose one of those locations at random. 

NOTE: Each zombie agent is characterized solely by its behavior. That is, the zombie agent does not have an internal state, and is only described by its unique agent tuple id.

NOTE: The 8 member neighborhood of grid cells surrounding an agent's 2D grid location is called its Moore neighborhood. Given a grid location, its 8 neighbors and the current location are computed using the
<<The Grid Neighbor Finder, GrdNghFinder>>.

[source,python,numbered]
----
from repast4py import core, space, schedule, logging, random
from repast4py.space import ContinuousPoint as cpt
from repast4py.space import DiscretePoint as dpt
...

class Zombie(core.Agent):
    ...
    def step(self):
        grid = model.grid    #<1>
        pt = grid.get_location(self)    <2>
        nghs = model.ngh_finder.find(pt.x, pt.y)    #<3> 

        at = dpt(0, 0)    #<4>
        maximum = [[], -(sys.maxsize - 1)]    #<5>
        for ngh in nghs:    #<6>
            at._reset_from_array(ngh)    #<7>
            count = 0    
            for obj in grid.get_agents(at):    #<8>
                if obj.uid[1] == Human.ID: 
                    count += 1
            if count > maximum[1]:    #<9>
                maximum[0] = [ngh]
                maximum[1] = count
            elif count == maximum[1]:    #<10>
                maximum[0].append(ngh)

        max_ngh = maximum[0][random.default_rng.integers(0, len(maximum[0]))]    #<11>

        if not np.all(max_ngh == pt.coordinates):    #<12>
            direction = (max_ngh - pt.coordinates[0:3]) * 0.25    #<13>
            cpt = model.space.get_location(self)    #<14>
            model.move(self, cpt.x + direction[0], cpt.y + direction[1])    #<15>

        pt = grid.get_location(self)    #<16>
        for obj in grid.get_agents(pt): 
            if obj.uid[1] == Human.ID: 
                obj.infect() 
                break
----
<1> The `Model` contains both the grid and continuous space in its `grid` and `space` fields. The `model`
variable contains the instance of the `Model` class.
<2> Get the location of this zombie. This location is a `Discrete Point`.
<3> Use the `Model's` instance of a `GridNghFinder` to get the Moore neighborhood
coordinates of the zombie's current location.
<4> Create a temporary 
{website}/apidoc/source/repast4py.space.html#repast4py.space.DiscretePoint[DiscretePoint]
for use in the loop over the Moore neighborhood coordinates.
<5> Initialize a list `maximum` that will be used to store the current maximum number of
human agents and the location(s) containing that maximum number. The first element
of the list stores the location(s), and the second the current maximum. 
We set the initial maximum number of humans as `-(sys.maxsize - 1)`,
the smallest negative integer. Consequently, if there are 0 neighboring humans
then that becomes the new maximum, and the `maximum` list always contains
at least one location.
<6> Iterate through all the neighboring locations to find the location(s) with the
maximum number of humans. For each neighbor location, we count the number of humans
at that location, and if the total count is equal to or greater than the current maximum, update
or reset the `maximum` list appropriately.
<7> Reset the the `at` `DiscretePoint` to the current neighbor coordinates. `get_agents_at`
takes a `DiscretePoint` argument and this converts the `ngh` numpy array to a `DiscretePoint`. 
<8> Get all the agents at the current neighbor location, and iterate through those agents to
count the number of humans. Humans are those agents where the type component of their
unique id tuple is equal to `Human.ID`.
<9> If the count is greater than the current maximum count, reset the `maximum` list
to the current location, and maximum count.
<10> If the count is equal to the current maximum count, then append the current location
to the `maximum` list
<11> Select one of the _maximum neighbor locations_ at random using Repast4Py's default random number
generator. See the {website}/apidoc/source/repast4py.random.html[API documentation] for more details.
<12> Check if the maximum neighbor location is the `Zombie's` current location,
using the `is_equal` function. If not, move the zombie toward the selected location.
<13> Calculate the direction to move by subtracting the `Zombie's` current location from its desired location. The zombie is only able to move a distance of `0.25` spaces per step (i.e., its speed is `0.25 spaces/tick`), and so we multiply the direction vector by `0.25`
<14> Get the `Zombie's` current location in the continous space. As with the grid, the `Model` class
instance `model` contains the continuous space over which the agents move.
<15> Move the zombie using the Model's `move()` method to the location computed by adding the current location
to the direction vector. `Model.move()` is described in <<Implementing Spatial Projections,the Implementing Spatial Projections subsection>>.
<16> Get the `Zombie's` current location in grid space and infect any humans found at that location. Infection in described in the <<The Human agent,next section>>.

NOTE: As each zombie is only moving 0.25 spaces, it is possible for the grid location that a zombie "moves to" to be the same as its grid location before moving. 

===== Saving the Zombie agent state

To move our zombie agent between processes, we must save its state. Because the zombie agent does not have an internal state, our `save` method returns only the zombie agent's unique id tuple.

[source,python,numbered]
----
class Zombie(core.Agent):

    ...

    def save(self):
        return (self.uid,)
----

==== The Human Agent

The human agent state is composed of two variables:

* Whether or not the human is infected are infected,
* The duration of the infection

Additionally, the human has the following behavior:

* Querying the current neigbhorhood for the fewest number of zombies
* Moving towards the location with the fewest number of zombies
* Becoming a zombie after 9 time steps, once infected.

We implement our human agents using the `Human` class, subclassing {website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`], passing it the components of the unique agent id tuple. 
The constructor also initializes the infected boolean to False and the duration of infection to 0.

[source,python,numbered]
----
from repast4py import core
...
class Human(core.Agent):    #<1>

    TYPE = 0    #<2>

    def __init__(self, a_id, rank):    
        super().__init__(id=a_id, type=Human.TYPE, rank=rank)    #<3>
        self.infected = False
        self.infected_duration = 0
    ...    
----
<1> `Human` subclasses `repast4py.core.Agent`. Subclassing `Agent` is a requirement for all Repast4Py agent implementations.
<2> `TYPE` is a class variable that defines the agent type id the Human agent. This is a required part of the unique agent id tuple.
<3> In order to uniquely identify the agent across all ranks in the simulation, the
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`]
constructor takes the following three arguments: an integer id that uniquely identifes an agent on the process where it was created, a non-negative integer identifying the type of the agent, and the rank on which the agent is created.

===== Human Behavior

Each human has three underlying behaviors: 

. Moving towards the area with the fewest zombies
. Becoming infected by a zombie

The <<_the_human_step()_method, `step()`>> method for the human agent implements (1), and the <<The infect() method, `infect()`>> method implements (2).

====== The Human step() Method
Much of the `Human step` method is similar to that of the zombie. The human
also queries the its Moore neighborhood, and moves in the direction of its
selected location. However, the human is searching for the location with
the fewest number of Zombies, and moves to that location. In addition,
the Human also increments its infected duration in the `step` method
and becomes a zombie if infected for 10 time steps.

Given the similarities
with the <<_the_zombie_step_method, `Zombie step()`>> method only the
relevant differences will be highlighted below.

[source,python,numbered]
----
class Human(core.Agent):

    ...

    def step(self):
        space_pt = model.space.get_location(self) 
        alive = True     <1>
        if self.infected:     <2>
            self.infected_duration += 1 
            alive = self.infected_duration < 10 

        if alive: 
            grid = model.grid 
            pt = grid.get_location(self)
            nghs = model.ngh_finder.find(pt.x, pt.y)  

            minimum = [[], sys.maxsize]    <3>
            at = dpt(0, 0, 0)
            for ngh in nghs:
                at._reset_from_array(ngh)
                count = 0
                for obj in grid.get_agents(at):
                    if obj.uid[1] == Zombie.TYPE:
                        count += 1
                if count < minimum[1]:    <4>
                    minimum[0] = [ngh]
                    minimum[1] = count
                elif count == minimum[1]:
                    minimum[0].append(ngh)

            min_ngh = minimum[0][random.default_rng.integers(0, len(minimum[0]))]

            if not is_equal(min_ngh, pt.coordinates):   
                direction = (min_ngh - pt.coordinates) * 0.5   
                model.move(self, 
                            space_pt.x + direction[0], space_pt.y + direction[1]) #<5>

        return (not alive, space_pt)    <6>
    
    ...
----
<1> Initialize an `alive` variable that specifies whether or not this human is still alive (not a Zombie).
<2> If the human is infected, increment its infection duration. If the infection duration is greater than
9, then set `alive` to `False`, indicating that this human should now become a zombie.
<3> Initialize a list `minimum` that will be used to store the current minimum number of
zombie agents and the location(s) containing that minimum number. The first element
of the list stores the location(s), and the second the current minimum. 
We set the initial minimum number of humans as `sys.maxsize`,
the largest integer, so that anything below that counts as the 
new minimum value.
<4> Checks if the zombie count is less than the current minimum value, updating 
appropriately if so.
<5> Moves this human using the same mechanism as the zombie, but twice as far, 0.5 vs 0.25.
<6> Return a tuple of `alive` and the `Human's` current location in the continuous space. This is returned
to the `Model` class calling code which will replace the human with a zombie if the human is no
longer alive.

====== The infect() method
We saw that zombies infect humans by calling the human's `infect()` method. This method
simply changes  the infected state from `False` to `True`. 
[source,python,numbered]
----
class Human(core.Agent):
    ...
    def infect(self):
        self.infected = True
----

===== Saving the Human Agent State
To move the human agent between processes, we must save its state. Unlike our zombie agent, saving the human state entails saving its `infected` and `infected_duration` states _in addition to_ its unique agent id tuple. The `save` method for the human agent was described in detail in the
previous <<Saving and Restoring Agents>> subsection.

// But for the sake of being comprehensive, we include the code snippet of the method here:

// [source,python,numbered]
// ----
// class Human(core.Agent):

//     ...

//     def save(self) -> Tuple:
//         """Saves the state of this Human as a Tuple.

//         Used to move this Human from one MPI rank to another.

//         Returns:
//             The saved state of this Human.
//         """
//         return (self.uid, self.infected, self.infected_duration)
// ----

==== Restoring the Agents
The `restore_agent` function is used to create an individual zombie or human when that agent has moved to another process. This function is passed to the synchronize method (i.e., `self.context.synchronize(restore_agent)`) and is called in the synchronization mechanism. This function has already
been  described in detail in <<Saving and Restoring Agents>>. #show that code again here??#

// [source,python,numbered]
// ----
// ...

// def restore_agent(agent_data: Tuple):
//     """Creates an agent from the specified agent_data.

//     This is used to re-create agents when they have moved from one MPI rank to another.
//     The tuple returned by the agent's save() method is moved between ranks, and restore_agent
//     is called for each tuple in order to create the agent on that rank. Here we also use
//     a cache to cache any agents already created on this rank, and only update their state
//     rather than creating from scratch.

//     Args:
//         agent_data: the data to create the agent from. This is the tuple returned from the agent's save() method
//                     where the first element is the agent id tuple, and any remaining arguments encapsulate
//                     agent state.
//     """
//     uid = agent_data[0]
//     # 0 is id, 1 is type, 2 is rank
//     if uid[1] == Human.TYPE:
//         if uid in agent_cache:
//             h = agent_cache[uid]
//         else:
//             h = Human(uid[0], uid[2])
//             agent_cache[uid] = h

//         # restore the agent state from the agent_data tuple
//         h.infected = agent_data[1]
//         h.infected_duration = agent_data[2]
//         return h
//     else:
//         # note that the zombie has no internal state
//         # so there's nothing to restore other than
//         # the Zombie itself
//         if uid in agent_cache:
//             return agent_cache[uid]
//         else:
//             z = Zombie(uid[0], uid[2])
//             agent_cache[uid] = z
//             return z
// ----

// Additionally, an `agent_cache` dictionary is defined and used when restoring agents: 

// [source,python,numbered]
// ----
// agent_cache = {}
// ----

// This dictionary is the cache of previously created agents. The dictionary keys are the agent unique ids, and the values are the agent instances. The dictionary is used for both Zombie and Human agents.


=== The Model class 

As was demonstrated in the earlier tutorials, the Model class encapsulates the simulation and is responsible for initialization, scheduling events, creating agents and their grid/space environment, and managng logging. In addition, the scheduled events that drive the simulation forward are methods of the Model class.

==== Scheduling Events and Creating the Context

For the Zombies model, the scheduling of events and the creation of the context are similar to the implementations in the <<Tutorial 1 - A Simple Model,Random Walker Model>>. For the Zombies model, both are implemented in the `Model` constructor.

[source,python,numbered]
----
from repast4py import core, space, schedule, logging, random
from repast4py import context as ctx
from repast4py.parameters import create_args_parser, init_params

...

class Model:

    def __init__(self, comm, params):
        self.comm = comm
        self.context = ctx.SharedContext(comm)    #<1>
        self.rank = self.comm.Get_rank()

        self.runner = schedule.init_schedule_runner(comm)    <2>
        self.runner.schedule_repeating_event(1, 1, self.step)    <3>
        self.runner.schedule_stop(params['stop.at'])    <4>
        self.runner.schedule_end_event(self.at_end)     <5>

        ...
    ...
----
<1> Creates a context to hold the agents and the network projection.
<2> Initialize schedule runner.
<3> Schedule the repeating event of `Model.step`, beginning at tick 1 and repeating every tick thereafter.  
<4> Schedule the tick at which the simulation should stop, and events will no longer be executed.
<5> Schedule a simulation end event to occur after events have stopped.

==== Implementing Spatial Projections

After initializing the schedule, adding events, and creating the context to hold the population of agents,
the `Model` constructor creates the two spatial projections, the 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[`SharedGrid`] and the
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[`SharedCSpace`]

Before we create our projections, we first must define a `BoundingBox` equal to the desired size of our space:
[source,python,numbered]
---- 
from repast4py import space

...

class Model:

    def __init__(self, comm, params):
        ... 
        box = space.BoundingBox(0, params['world.width'], 
                                0, params['world.height'], 0, 0)    <1>
        self.grid = space.SharedGrid('grid', bounds=box, borders=BorderType.Sticky, 
                                     occupancy=OccupancyType.Multiple,
                                     buffer_size=2, comm=comm)    <2>
        self.context.add_projection(self.grid)    <3>
        self.space = space.SharedCSpace('space', bounds=box, borders=BorderType.Sticky,
                                        occupancy=OccupancyType.Multiple,
                                        buffer_size=2, comm=comm, 
                                        tree_threshold=100)    <4>
        self.context.add_projection(self.space)    <5>
----
<1> Create a  BoundingBox to initialize the size of the Cartesian spaces. Its
arguments are the minimum x coordinate, the extent of the x dimension, and then the same for
the y and z dimensions. Here we create a 2D box (the z extent is 0) starting at (0,0) and
extending for `params['world.width]` in the x dimension and `params['world.height']` in
the y dimension.
<2> Create the grid projection. `repast4py.space.SharedGrid` takes a name, its bounds, its border, 
and occupancy types, as well as a buffer size, and a MPI communicator as arguments. See the `SharedGrid`
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[API documentation]
for a description of these arguments. The concept of a buffer was described in the
xref:overview.adoc#_distributed_simulation[Distributed Simulation] section.
<3> Add the grid to the context so that it can be properly synchronized across
processes.
<4> Create the space projection. `repast4py.space.SharedCSpace` takes a name, its bounds, its border, 
and occupancy types, as well as a buffer size, a MPI communicator, and a
tree threshod as arguments. See the `SharedCSpace`
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[API documentation]
for a description of these arguments.
<5> Add the space to the context so that it can be properly synchronized across
processes.

We use two spatial projections in our Zombies model: a discrete `grid` projection, and a continuous `space` projection. Even though the `space` and `grid` projections are distinct from each other, they are
inialized with the same bounding box. Thus, they are the same size, which allows us to translate between the two projections such that the grid is overlaid on the continuous space. As you have seen, the
grid is used for neighborhood queries, and the continous space for movement.

Within the `Model` class, a `move` method is defined and called by during the movment 
sections of the agents' step methods (<<The Zombie step() Method, `Zombie.step()`>> and <<The Human step() Method, `Human.step()`>>). This `move` method performs the translation and movement on both the
grid and continuous space.

[source,python,numbered]
----
from repast4py.space import ContinuousPoint as cpt
from repast4py.space import DiscretePoint as dpt
...

class Model:

    ...

    def move(self, agent, x, y): #<1>
        self.space.move(agent, cpt(x, y)) #<2>
        self.grid.move(agent, dpt(int(math.floor(x)), int(math.floor(y)))) #<3>

    ...    
----
<1> Pass the `move` method the `x` and `y` coordinates in the `space` projection that the agent
argument is moving to.
<2> Move the agent to the specified point in the continuous space, creating a new ContinuousPoint from
the x and y coordinates. See the `move` 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace.move[API documentation] for
more details.
<3> Move the agent to the corresponding location in the grid space. The grid takes
a DiscretePoint as its location argument. To create one, we take the floor of the
x and y coordinates, convert those to ints, and create a DiscretePoint from those ints.
See the `move` 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid.move[API documentation] for
more details.

==== Creating the Agents

The population of agents is created within the Model class. The model input
parameters `human.count` and `zombie.count` specify the total number of humans and zombies to create. 
These total amounts are distributed evenly among each process rank,
with any remainder accounted for by assigning one agent to each rank,
starting with 0, until the total amount has been distributed. 

Once the number of agents to create on each rank has been computed,
that number of agents is created, assigning each a random location
in the grid and continuous space.

[source,python,numbered]
----
class Model:

    def __init__(self, comm, params):
        self.rank = self.comm.Get_rank()    #<1>
        ...
        world_size = comm.Get_size()    #<2>

        total_human_count = params['human.count']    #<3>
        pp_human_count = int(total_human_count / world_size)    #<4>
        if self.rank < total_human_count % world_size:    #<5>
            pp_human_count += 1

        local_bounds = self.space.get_local_bounds()    #<6>
        for i in range(pp_human_count):    #<7>
            h = Human(i, self.rank)    #<8>
            self.context.add(h)    #<9>
            x = random.default_rng.uniform(local_bounds.xmin, local_bounds.xmin 
                                           + local_bounds.xextent)    #<10>
            y = random.default_rng.uniform(local_bounds.ymin, local_bounds.ymin 
                                           + local_bounds.yextent)
            self.move(h, x, y)    #<11>

        ...

    ...
----
<1> Get the rank that is executing this code, the current process rank.
<2> Get the number of process ranks over which the simulation is distributed.
<3> Get the total number of Humans to create from the input parameters dictionary.
<4> Compute an average number of Human agents per processor.
<5> Increment the number of agents to create on this rank, if this rank's id is less than the number
of remaining agents to create. This will assign each rank, starting with 0, an additional agent
in order to reach the total when the total number of agents cannot be evenly divided among all the
process ranks.
<6> Get the local bounds of the continous space. Each rank is responsible for some
part of the total area defined by the space's bounding box. For example, assuming
4 process ranks, each rank would be responsible for some quadrant of the space. 
`get_local_bounds` returns the area that the calling rank is responsible for as 
a `BoundingBox`.
<7> Iterate through the number of humans to be assigned to each rank.
<8> Create a `Human` agent .
<9> Add the new human agent to the context
<10> Choose a random x and y location within the current local bounds using repast4py's
default randon number generator. See the {website}/apidoc/source/repast4py.random.html[API documentation] for more details.
<11> Move the new `Human` agent to that location, using `Model.move`.

The code for creating the zombie agents is nearly identical, except that the 
the `zombie.count` input parameter is used as the total number of agents to create,
and a `Zombie` agent is created rather than a `Human`.

[source,python,numbered]
----
class Model:

    def __init__(self, comm, params):

        ...

        total_zombie_count = params['zombie.count']
        pp_zombie_count = int(total_zombie_count / world_size)
        if self.rank < total_zombie_count % world_size:
            pp_zombie_count += 1

        for i in range(pp_zombie_count):
            zo = Zombie(i, self.rank)
            self.context.add(zo)
            x = random.default_rng.uniform(local_bounds.xmin, local_bounds.xmin + local_bounds.xextent)
            y = random.default_rng.uniform(local_bounds.ymin, local_bounds.ymin + local_bounds.yextent)
            self.move(zo, x, y)

        self.zombie_id = pp_zombie_count    #<1>
    ...
----
<1> Set the next integer id for newly created `Zombies` to the number of zombies created on this rank.
When a human becomes a zombie, this `zombie_id` is used as the id of that new zombie, and then incremented
for the next time a human becomes a zombie.

==== Logging

As we saw in <<_tutorial_1_a_simple_random_walk_model, Tutorial 1>>, there are
two types of logging supported by Repast4Py, tabular and reduce-type logging (see the `repast4py.logging` module
{website}/apidoc/source/repast4py.logging.html#module-repast4py.logging[API documentation] for more information).

The Zombies model uses the second of these log types. The dataclass that we log records
the total number of humans and zombies each tick.

===== Initializing Logging

[source,python,numbered]
----
@dataclass
class Counts:
    humans: int = 0
    zombies: int = 0


class Model:

    def __init__(self, comm, params):
        ...
        self.counts = Counts()    #<1>
        loggers = logging.create_loggers(self.counts, op=MPI.SUM, rank=self.rank)    #<2>
        self.data_set = logging.ReducingDataSet(loggers, self.comm, params['counts_file'])    #<3>
----
<1> Create the `Counts` instance that we use to record the number of `Humans` and `Zombies`
on each rank.
<2> Create a list of loggers that use `self.counts` as the source of the data to log,
and that perform a cross process rank summation of that data. The `names` argument is not 
specified, so the `Counts` field names will be used as column headers.
<3> Create a `logging.ReducingDataSet` from the list of loggers. `params['counts_file']` is the name of the file to log to. 

===== The `log_counts` Method

Each tick the `log_counts` method is called by `Model.step()` to record the number
of `Humans` and `Zombies` at that tick.

[source,python,numbered]
----
class Model:

    def log_counts(self, tick):
        # Get the current number of zombies and humans and log
        num_agents = self.context.size([Human.TYPE, Zombie.TYPE])    #<1>
        self.counts.humans = num_agents[Human.TYPE]    #<2>
        self.counts.zombies = num_agents[Zombie.TYPE]    #<3>
        self.data_set.log(tick)    #<4>
----
<1> Get the number of agents of the specified types currently in the context.
{website}/apidoc/source/repast4py.context.html#repast4py.context.SharedContext.size[`context.size`]
takes a list of agent type ids and returns a dictionary where the type ids are the keys
and the values are the number of agents of that type.
<2> Set the `self.counts.humans` to the number of `Humans`
<3> Set the `self.counts.zombies` to the number of `Zombies`
<4> Log the values for the specified tick. This will sum the values in `self.counts`
across all the ranks and log the results.

==== Scheduled Methods

The events for this model are methods defined within the Model class.

===== Step 

The first of our scheduled events is the `step` method, which is scheduled to execute starting at tick 1 and for every tick thereafter:

[source,python,numbered]
----
class Model:

    ...

    def step(self):
        tick = self.runner.schedule.tick    #<1>
        self.log_counts(tick)    #<2>
        self.context.synchronize(restore_agent)    #<3>

        for z in self.context.agents(Zombie.TYPE):    #<4>
            z.step()   

        dead_humans = []    #<5>
        for h in self.context.agents(Human.TYPE):    #<6>
            dead, pt = h.step() 
            if dead:     #<7>
                dead_humans.append((h, pt))

        for h, pt in dead_humans: #<8>
            model.remove_agent(h)
            model.add_zombie(pt)
----
<1> Get the current tick value from the schedule runner.
<2> Log the current number of `Humans` and `Zombies` by calling the <<_the_log_counts_method,`log_counts`>> method.
<3> Synchronize the state of the simulation across processes using the `restore_agent` function to restore any agents (Zombies and Humans) that have moved processes. See <<Saving and Restoring Agents>> for more details.
<4> Iterate over all the Zombie agents in the model, calling <<_the_zombie_step_method, `step`>> on each one.
<5> Create an empty list for collecting the dead `Humans` and their current location. This is used
later in `step` to replace the `Humans` with `Zombies`.
<6> Iterate over all the Human agents in the model, calling <<_the_human_step_method, `step`>> on each one.
`Human.step` returns a boolean that indicates whether or not the `Human` has died (and thus should become a `Zombie`), and the current location of that `Human`.
<7> If the `Human` has died, then append it and its current location to the `dead_humans` list.
<8> Iterate over the dead human data, removing the human from the model, and replacing it with a `Zombie`
at its former location.

IMPORTANT: The iterator returned from `SharedContext.agents` is not modifiable during
iteration, that is, it is not possible to remove an agent from the `SharedContext` as part
of the iteration.

Given that it is not possible to remove an agent as part of iteration, we need to
collect the `Humans` to remove in a list. After the iteration has completed, 
we can iterate over that list, and remove the agents using `Model.remove_agent`

[source,python,numbered]
----
class Model:

    def remove_agent(self, agent):
        self.context.remove(agent)    <1>
----
<1>Remove the agent from the context.

Humans are converted into zombies in the `add_zombie()` method. which adds a new `Zombie` agent at the final location of the newly removed `Human`.

[source,python,numbered]
----
class Model:

    def add_zombie(self, pt):    #<1>
        z = Zombie(self.zombie_id, self.rank)    #<2>
        self.zombie_id += 1    #<3>
        self.context.add(z)    #<4>
        self.move(z, pt.x, pt.y)    #<5>
----
<1> The final location of the human agent that just died is passed into the `add_zombie` method
<2> Create a new `Zombie` agent, using the `zombie_id` field instantiated in the constructor.
<3> Increment the `zombie_id` to create the id for the next created `Zombie`.
<4> Add the newly created zombie to the Model's context
<5> Move the `Zombie` to the location of the dead `Human` the Zombie is replacing.

===== At End

`Model.at_end` when the simulation reaches its final tick and ends. This method closes the `data_set` log, ensuring that any remaining unwritten data is written to the output file.
[source,python,numbered]
----
class Model:

    def at_end(self):
        self.data_set.close()
----


=== The Grid Neighborhood Finder

Every agent at every tick must search their neighborhood of grid locations to determine which grid location has the most `Humans` or the fewest `Zombies`. Because this neighborhood of grid locations is dependent on each agent's current location, the neighborhood must be computed _every_ tick for _every_ agent. If, for example, the simulation is run for _50_ ticks and _8400_ agents, the neighborhood finding code is run over _400,000_ times. Consequently, neighborhood finding is a good candidate for optimization, and a good example
of how such an optimization can be implemented using 3rd party Python libraries.

The `GridNghFinder` is a class that can quickly compute these neighboring grid locations 
using the https://numpy.org[NumPy] and
https://numba.pydata.org[Numba] Python packages. NumPy is the fundamental Python package for
scientific computing, providing support for multi-dimensional arrays and matrices, along with
fast optimized mathematical functions that operate on those arrays. Numba is a _just-in-time_ compiler for Python. It can compile certain kinds of Python functions and classes into optimized
native machine code that by-passes the slower Python interpreter.
It is particularly useful for code that is numerically oriented and uses NumPy arrays.

TIP: The `Numba` library provides a useful https://numba.readthedocs.io/en/stable/user/5minguide.html["5 minute guide to Numba"] overview on their package's webpage. We encourage you to take a look at that page for more information regarding how and why such a package may be useful when implementing your model. Similarly,
more information on `NumPy` and whether it might be useful for your model can be found https://numpy.org/doc/stable/user/whatisnumpy.html[here].

We implement our `GridNghFinder` as a class. Neighborhood finding in the `GridNghFinder` 
works by taking a location and adding an array of offsets to that location to create a new array consisting of the neighboring
coordinates. For example, if we want to get the left and right coordinate values along the x-axis
for an x coordinate of 4, we can add the array [-1, 1] to 4 resulting in the array [3, 5]. The
`GridNghFinder` performs this operation using 9 element offset arrays in both the x and y
dimensions. 9 elements yields the Moore neighborhood coordinates as well as the original
center location. The `GridNghFinder` also performs some additional checks
to make sure that the coordinates are not outside of the bounds of the grid.
The arrays in this case are NumPy arrays, and given the numeric
nature of the operation, Numba can compile it into native code. 

In order to utilize Numba for our `GridNghFinder` class, we must first declare the native data types of the fields used in our class.

[source,python,numbered]
----
from numba import int32

spec = [    <1>
    ('mo', int32[:]),   <2>
    ('no', int32[:]),
    ('xmin', int32),    <3>
    ('ymin', int32),
    ('ymax', int32),
    ('xmax', int32)
]
----
<1> Create a Numba class specification. The specification is a list of tuples,
where each tuple consists of a field name, and the native type of that field.
The names correspond with the field names in the class for which this is the specification.
<2> Create a tuple for the `mo` field with a numpy array of 32-bit integers as its type.
<3> Create a tuple for the `xmin` fields with a 32-bit integer type.

See the Numba https://numba.readthedocs.io/en/stable/user/jitclass.html[API documentation]
for `@jitclass` for more details on compiling classes with Numba.


The `GridNghFinder` constructor initializes the offset arrays and global grid bounds.

[source,python,numbered]
----
from numba.experimental import jitclass    #<1>

@jitclass(spec)   #<2>
class GridNghFinder:

    def __init__(self, xmin, ymin, xmax, ymax):   #<3>
        self.mo = np.array([-1, 0, 1, -1, 0, 1, -1, 0, 1], dtype=np.int32)    #<4>
        self.no = np.array([1, 1, 1, 0, 0, 0, -1, -1, -1], dtype=np.int32)
        self.xmin = xmin    #<5>
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax
----
<1> Import the `numba.jitclass` decorator
<2> Decorate `GridNghFinder` with `jitclass` passing our `spec` that defines the field types. 
<3> Pass the global grid bounds to the constructor as x and y maximum and minimum values.
<4> Create the `mo` and `no` offset arrays containing the specified 32-bit integers. 
<5> Set the minimum and maximum possible x and y values from the passed in global grid bounds.

The neighborhood coordinate computation is performed in the `find` method.

[source,python,numbered]
----
    def find(self, x, y):    #<1>
        xs = self.mo + x    #<2>
        ys = self.no + y    #<3>

        xd = (xs >= self.xmin) & (xs <=self.xmax)    #<4>
        xs = xs[xd]   #<5>
        ys = ys[xd]   #<6>

        yd = (ys >= self.ymin) & (ys <= self.ymax)    #<7>
        xs = xs[yd]
        ys = ys[yd]

        return np.stack((xs, ys, np.zeros(len(ys), dtype=np.int32)), axis=-1)    #<8>
----
<1> The `find` method takes a 2D location specified as a x and y coordinate. This location
is the location we want the neighboring coordinates of.
<2> Add the x offset array to the x coordinate, resulting in a new array `xs` that contains the
neighboring x-axis coordinates.
<3> Add the y offset array to the y coordinate, resulting in a new array `ys` that contains the
neighboring y-axis coordinates.
<4> Compute the array indices in the `xs` array whose values are within the global x-axis bounds.
<5> Keep only those values from `xs`, assigning that array to `xs`
<6> Do the same for the `ys` array. If x value is out of bounds, we discard its corresponding y value.
<7> Compute the array indices in the `ys` array whose values are within the global y-axis bounds.
Then reset `xs` and `ys` to contain only the values at those indices.
<8> Combine the `xs` and `ys` indices with each other and a z-axis coordinate array of all zeros
to create an array of arrays where the inner arrays are 3D points consisting of 
a x, y, and z coordinate. This 3 element array format is necessary to reset the
`repast4py.space.DiscretePoint` `at` variable that is used in both the <<The Zombie step() Method, Zombie step>>, method and the <<The Human step() Method, Human step>> method.


=== Running the Simulation
The simulation is run from the command line. For example, from within the
`examples/zombies` directory:

`mpirun -n 4 python zombies.py zombie_model.yaml`

Here we are running the simulation with 4 process ranks and the model input parameters are
in the `zombie_model.yaml` file.

[source,yaml,numbered]
----
random.seed: 42
stop.at: 50.0
human.count: 8000
zombie.count: 400
world.width: 200
world.height: 200
run.number: 1
counts_file: './output/agent_counts.csv'
----

The Zombie Model uses the standard `if __name__ == '__main__'` code block to parse the input parameters and
run the simulation. 

[source,python,numbered]
----
if __name__ == "__main__":
    parser = parameters.create_args_parser()    <1>
    args = parser.parse_args()   <2>
    params = parameters.init_params(args.parameters_file, args.parameters)    <3>
    run(params)   <4>
----
<1> Create the default command line argument parser
<2> Parse the command line into its arguments using that default parser
<3> Create the model input parameters dictionary from those arguments using
`parameters.init_params`
<4> Call the `run` function to run the simulation.

See <<_parsing_input_parameters, Parsing Input Parameters>> in Tutorial 1 for more details.

The `run` function creates the Model class and calls its `run` method, which then begins the simulation by initiating schedule execution. This run function is called in the `if name == 'main'` code block.

[source,python,numbered]
----
from mpi4py import MPI

def run(params: Dict):
    global model    <1>
    model = Model(MPI.COMM_WORLD, params)   <2>
    model.run()

class Model:

    def run(self):
        self.runner.execute()    <3>
----
<1> Use the `global` keyword to indicate that `model` refers to the package level `model` variable
and not a local variable.
<2> Create the Model, passing it the MPI world communicator and the input parameters dictionary.
<3> Start the simulation by executing the schedule which
calls the scheduled methods at the appropriate times and frequency.

NOTE: The code in the `run` function could be moved to the `if __name__ == '__main__'` code block,
but it is often useful to have an entry type function that initializes and starts a simulation.



