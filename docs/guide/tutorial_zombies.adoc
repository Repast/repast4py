== Tutorial 3 - The Zombies Model

In <<_tutorial_1_a_simple_random_walk_model,Tutorial 1>>, we developed a simple model in which agents walk at random around a 2-dimensional Cartesian grid. The Zombies Model builds on this simple movement implementation, adding an additional agent type and using a Continuous Space. 

*This text assumes you have already read the _Repast4Py Users Guide_ up through <<_tutorial_1_a_simple_random_walk_model,Tutorial 1>>.*

In the Zombies model, human agents are pursued by zombie agents, and once caught become zombies themselves. Each timestep, the following occurs:

. All the Zombies:
  .. Query their immediate neighborhood to determine the adjacent grid location with
the most number of Humans
  .. Move towards that location, assuming any Humans are found
  .. Infect the Humans at that location, also assuming any Humans are found
. All the Humans:
  .. Become a Zombie, after being infected for more than 9 timesteps, else
  .. Query their immediate neighborhood to determine the adjacent grid location with
the fewest number of Zombies
  .. Move to that location at twice the speed of a Zombie.

See the {website}/examples/examples.html[Repast4Py Examples] page to download the source code for this model 
and for more information on getting started with the examples.

The code consists of the following components:

* Two agent classes: a <<The Zombie Agent, Zombie class>> that implements the behavior of the zombie agents, and a <<The Human Agent, Human class>> that implements the state and behavior of the human agents.
* <<Restoring the Agents, A restore function>> that creates both Zombie and Human agents when they are moved from one MPI rank to another.
* A <<The Model class, Model class>> responsible for initializing and managing the simulation and
simulation components, including:
** the model's <<Scheduling Events and Creating the Context, context>>
** <<Implementing Spatial Projections, Continuous Space and Discrete Grid>> projections, 
** <<Scheduled methods, Scheduled Events>>, and
** <<Logging,Logging>>
* A <<_the_grid_neighbor_finder, GridNghFinder>> class for quickly computing neighboring grid locations using
numpy and the the https://numba.pydata.org[Numba] Python package to accelerate the computation
* The standard `run` function that creates and starts the simulation.
* The standard `if __name__ == "__main__"` block in which input parameters are parsed and
allows the simulation to be run from the command line.

NOTE: The Model class instance `model` is a global variable defined as an attribute of the
zombies module itself. Consequenly, it is available to all the code in `zombies.py` as just
`model`, that is, you will see it referenced as `model` rather than `self.model` or as a 
function argument.  

=== The Agent Classes

The Zombies model implements two agent classes: a `Zombie` and a `Human`. The zombie's behavior
is to pursue humans across a two dimensional Cartesian space and infect them. The human's behavior
is to flee from zombies. Humans contain a boolean (`infected`) field indicating whether or not they are infected, and an integer (`infected_duration`) field tracking the duration of the infection. When that
value reaches 10, that human is replaced with a zombie. The methods that implement infection, and 
the transition from human to zombie are described in <<The Zombie step() Method,the Zombie step method>>, the <<The Human step() Method,the Human step method>>, and <<Step,the Model class scheduled step method>>. 

Both agents inhabit two two-dimensional projections:
a {website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[`SharedGrid`] and a
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[`SharedCSpace`]. The
first of these is a matrix type grid where the agent locations are expressible
as discrete integer coordinates. The second is a continuous space where the agent locations
are expressible as continuous floating point coordinates. The grid is used to implement agent
vision. Humans and zombies can _see_ the zombies and humans in the grid locations
that neighbor their own, and act accordingly. The continuous space is used for movement, and
unlike the `Walker` agents in <<_tutorial_1_a_simple_random_walk_model, Tutorial 1>> which move a single
grid unit at a time, the human and zombie agents move in fractions of a grid unit, 
0.25 for zombies, and 0.5 grid units for humans. In this way, the humans are twice as fast as
the zombies. When a human or zombie moves in the continuous space, a method in the
`Model` class updates its location in the grid space. These spatial aspects are described in
detail in the <<Implementing Spatial Projections>> subsection.
 
==== The Zombie Agent

We implement our Zombie agent using the `Zombie` class. As required for all Repast4Py agent implementations, the `Zombie` class extends
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`], passing it the components of the unique agent id tuple.

[source,python,numbered]
----
from repast4py import core

...

class Zombie(core.Agent): #<1>

    TYPE = 1 #<2>

    def __init__(self, a_id, rank): #<3>
        super().__init__(id=a_id, type=Zombie.TYPE, rank=rank)

    ...
----
<1> `Zombie` subclasses `repast4py.core.Agent`. Subclassing `Agent` is a requirement for all Repast4Py agent implementations.
<2> `TYPE` is a class variable that defines the agent type id for the Zombie agents. This is a required part of the unique agent id tuple. 
<3> In order to uniquely identify the agent across all ranks in the simulation, the
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`] constructor takes the following three arguments: an integer id that uniquely identifies an agent on the process where it was created, a non-negative integer identifying the type of the agent, and the rank on which the agent is created.

===== The Zombie step() Method
The zombie agent behavior is implemented in its `step` method. Here, the zombie queries its immediate neighborhood to find the location with the most humans. Assuming some humans are found, the zombie will then move towards that grid location. If multiple grid locations have the maximum number of humans, including when the maximum is 0, the zombie will choose one of those locations at random. 

NOTE: Each zombie agent is characterized solely by its behavior. That is, the zombie agent does not have an internal state, and is only described by its unique agent tuple id.

NOTE: The 8 member neighborhood of grid cells surrounding an agent's 2D grid location is called its Moore neighborhood. Given a grid location, its 8 neighbors and the current location are computed using the
<<The Grid Neighbor Finder, GrdNghFinder>>.

[source,python,numbered]
----
from repast4py import core, space, schedule, logging, random
from repast4py.space import ContinuousPoint as cpt
from repast4py.space import DiscretePoint as dpt
...

class Zombie(core.Agent):
    ...
    def step(self):
        grid = model.grid    #<1>
        pt = grid.get_location(self)    <2>
        nghs = model.ngh_finder.find(pt.x, pt.y)    #<3> 

        at = dpt(0, 0)    #<4>
        maximum = [[], -(sys.maxsize - 1)]    #<5>
        for ngh in nghs:    #<6>
            at._reset_from_array(ngh)    #<7>
            count = 0    
            for obj in grid.get_agents(at):    #<8>
                if obj.uid[1] == Human.ID: 
                    count += 1
            if count > maximum[1]:    #<9>
                maximum[0] = [ngh]
                maximum[1] = count
            elif count == maximum[1]:    #<10>
                maximum[0].append(ngh)

        max_ngh = maximum[0][random.default_rng.integers(0, len(maximum[0]))]    #<11>

        if not np.all(max_ngh == pt.coordinates):    #<12>
            direction = (max_ngh - pt.coordinates[0:3]) * 0.25    #<13>
            cpt = model.space.get_location(self)    #<14>
            model.move(self, cpt.x + direction[0], cpt.y + direction[1])    #<15>

        pt = grid.get_location(self)    #<16>
        for obj in grid.get_agents(pt): 
            if obj.uid[1] == Human.ID: 
                obj.infect() 
                break
----
<1> The `Model` contains both the grid and continuous space in its `grid` and `space` fields. The `model`
variable contains the instance of the `Model` class.
<2> Get the location of this zombie. This location is a `Discrete Point`.
<3> Use the `Model's` instance of a `GridNghFinder` to get the Moore neighborhood
coordinates of the zombie's current location.
<4> Create a temporary 
{website}/apidoc/source/repast4py.space.html#repast4py.space.DiscretePoint[DiscretePoint]
for use in the loop over the Moore neighborhood coordinates.
<5> Initialize a list `maximum` that will be used to store the current maximum number of
human agents and the location(s) containing that maximum number. The first element
of the list stores the location(s), and the second the current maximum. 
We set the initial maximum number of humans as `-(sys.maxsize - 1)`,
the smallest negative integer. Consequently, if there are 0 neighboring humans
then that becomes the new maximum, and the `maximum` list always contains
at least one location.
<6> Iterate through all the neighboring locations to find the location(s) with the
maximum number of humans. For each neighbor location, we count the number of humans
at that location, and if the total count is equal to or greater than the current maximum, update
or reset the `maximum` list appropriately.
<7> Reset the the `at` `DiscretePoint` to the current neighbor coordinates. `get_agents_at`
takes a `DiscretePoint` argument and this converts the `ngh` numpy array to a `DiscretePoint`. 
<8> Get all the agents at the current neighbor location, and iterate through those agents to
count the number of humans. Humans are those agents where the type component of their
unique id tuple is equal to `Human.ID`.
<9> If the count is greater than the current maximum count, reset the `maximum` list
to the current location, and maximum count.
<10> If the count is equal to the current maximum count, then append the current location
to the `maximum` list
<11> Select one of the _maximum neighbor locations_ at random using Repast4Py's default random number
generator. See the {website}/apidoc/source/repast4py.random.html[API documentation] for more details.
<12> Check if the maximum neighbor location is the `Zombie's` current location,
using the `is_equal` function. If not, move the zombie toward the selected location.
<13> Calculate the direction to move by subtracting the `Zombie's` current location from its desired location. The zombie is only able to move a distance of `0.25` spaces per step (i.e., its speed is `0.25 spaces/tick`), and so we multiply the direction vector by `0.25`
<14> Get the `Zombie's` current location in the continous space. As with the grid, the `Model` class
instance `model` contains the continuous space over which the agents move.
<15> Move the zombie using the Model's `move()` method to the location computed by adding the current location
to the direction vector. `Model.move()` is described in <<Implementing Spatial Projections,the Implementing Spatial Projections subsection>>.
<16> Get the `Zombie's` current location in grid space and infect any humans found at that location. Infection in described in the <<The Human agent,next section>>.

NOTE: As each zombie is only moving 0.25 spaces, it is possible for the grid location that a zombie "moves to" to be the same as its grid location before moving. 

===== Saving the Zombie agent state

To move our zombie agent between processes, we must save its state. Because the zombie agent does not have an internal state, our `save` method returns only the zombie agent's unique id tuple.

[source,python,numbered]
----
class Zombie(core.Agent):

    ...

    def save(self):
        return (self.uid,)
----

==== The Human Agent

The human agent state is composed of two variables:

* Whether or not the human is infected are infected,
* The duration of the infection

Additionally, the human has the following behavior:

* Querying the current neigbhorhood for the fewest number of zombies
* Moving towards the location with the fewest number of zombies
* Becoming a zombie after 9 time steps, once infected.

We implement our human agents using the `Human` class, subclassing {website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`], passing it the components of the unique agent id tuple. 
The constructor also initializes the infected boolean to False and the duration of infection to 0.

[source,python,numbered]
----
from repast4py import core
...
class Human(core.Agent):    #<1>

    TYPE = 0    #<2>

    def __init__(self, a_id, rank):    
        super().__init__(id=a_id, type=Human.TYPE, rank=rank)    #<3>
        self.infected = False
        self.infected_duration = 0
    ...    
----
<1> `Human` subclasses `repast4py.core.Agent`. Subclassing `Agent` is a requirement for all Repast4Py agent implementations.
<2> `TYPE` is a class variable that defines the agent type id the Human agent. This is a required part of the unique agent id tuple.
<3> In order to uniquely identify the agent across all ranks in the simulation, the
{website}/apidoc/source/repast4py.core.html#repast4py.core.Agent[`repast4py.core.Agent`]
constructor takes the following three arguments: an integer id that uniquely identifes an agent on the process where it was created, a non-negative integer identifying the type of the agent, and the rank on which the agent is created.

===== Human Behavior

Each human has three underlying behaviors: 

. Moving towards the area with the fewest zombies
. Becoming infected by a zombie

The <<_the_human_step()_method, `step()`>> method for the human agent implements (1), and the <<The infect() method, `infect()`>> method implements (2).

====== The Human step() Method
Much of the `Human step` method is similar to that of the zombie. The human
also queries the its Moore neighborhood, and moves in the direction of its
selected location. However, the human is searching for the location with
the fewest number of Zombies, and moves to that location. In addition,
the Human also increments its infected duration in the `step` method
and becomes a zombie if infected for 10 time steps.

Given the similarities
with the <<_the_zombie_step_method, `Zombie step()`>> method only the
relevant differences will be highlighted below.

[source,python,numbered]
----
class Human(core.Agent):

    ...

    def step(self):
        space_pt = model.space.get_location(self) 
        alive = True     <1>
        if self.infected:     <2>
            self.infected_duration += 1 
            alive = self.infected_duration < 10 

        if alive: 
            grid = model.grid 
            pt = grid.get_location(self)
            nghs = model.ngh_finder.find(pt.x, pt.y)  

            minimum = [[], sys.maxsize]    <3>
            at = dpt(0, 0, 0)
            for ngh in nghs:
                at._reset_from_array(ngh)
                count = 0
                for obj in grid.get_agents(at):
                    if obj.uid[1] == Zombie.TYPE:
                        count += 1
                if count < minimum[1]:    <4>
                    minimum[0] = [ngh]
                    minimum[1] = count
                elif count == minimum[1]:
                    minimum[0].append(ngh)

            min_ngh = minimum[0][random.default_rng.integers(0, len(minimum[0]))]

            if not is_equal(min_ngh, pt.coordinates):   
                direction = (min_ngh - pt.coordinates) * 0.5   
                model.move(self, 
                            space_pt.x + direction[0], space_pt.y + direction[1]) #<5>

        return (not alive, space_pt)    <6>
    
    ...
----
<1> Initialize an `alive` variable that specifies whether or not this human is still alive (not a Zombie).
<2> If the human is infected, increment its infection duration. If the infection duration is greater than
9, then set `alive` to `False`, indicating that this human should now become a zombie.
<3> Initialize a list `minimum` that will be used to store the current minimum number of
zombie agents and the location(s) containing that minimum number. The first element
of the list stores the location(s), and the second the current minimum. 
We set the initial minimum number of humans as `sys.maxsize`,
the largest integer, so that anything below that counts as the 
new minimum value.
<4> Checks if the zombie count is less than the current minimum value, updating 
appropriately if so.
<5> Moves this human using the same mechanism as the zombie, but twice as far, 0.5 vs 0.25.
<6> Return a tuple of `alive` and the `Human's` current location in the continuous space. This is returned
to the `Model` class calling code which will replace the human with a zombie if the human is no
longer alive.

====== The infect() method
We saw that zombies infect humans by calling the human's `infect()` method. This method
simply changes  the infected state from `False` to `True`. 
[source,python,numbered]
----
class Human(core.Agent):
    ...
    def infect(self):
        self.infected = True
----

===== Saving the Human Agent State
To move the human agent between processes, we must save its state. Unlike our zombie agent, saving the human state entails saving its `infected` and `infected_duration` states _in addition to_ its unique agent id tuple. The `save` method for the human agent was described in detail in the
previous <<Saving and Restoring Agents>> subsection. #Show that code again here?#

// But for the sake of being comprehensive, we include the code snippet of the method here:

// [source,python,numbered]
// ----
// class Human(core.Agent):

//     ...

//     def save(self) -> Tuple:
//         """Saves the state of this Human as a Tuple.

//         Used to move this Human from one MPI rank to another.

//         Returns:
//             The saved state of this Human.
//         """
//         return (self.uid, self.infected, self.infected_duration)
// ----

==== Restoring the Agents
The `restore_agent` function is used to create an individual zombie or human when that agent has moved to another process. This function is passed to the synchronize method (i.e., `self.context.synchronize(restore_agent)`) and is called in the synchronization mechanism. This function has already
been  described in detail in <<Saving and Restoring Agents>>. #show that code again here??#

// [source,python,numbered]
// ----
// ...

// def restore_agent(agent_data: Tuple):
//     """Creates an agent from the specified agent_data.

//     This is used to re-create agents when they have moved from one MPI rank to another.
//     The tuple returned by the agent's save() method is moved between ranks, and restore_agent
//     is called for each tuple in order to create the agent on that rank. Here we also use
//     a cache to cache any agents already created on this rank, and only update their state
//     rather than creating from scratch.

//     Args:
//         agent_data: the data to create the agent from. This is the tuple returned from the agent's save() method
//                     where the first element is the agent id tuple, and any remaining arguments encapsulate
//                     agent state.
//     """
//     uid = agent_data[0]
//     # 0 is id, 1 is type, 2 is rank
//     if uid[1] == Human.TYPE:
//         if uid in agent_cache:
//             h = agent_cache[uid]
//         else:
//             h = Human(uid[0], uid[2])
//             agent_cache[uid] = h

//         # restore the agent state from the agent_data tuple
//         h.infected = agent_data[1]
//         h.infected_duration = agent_data[2]
//         return h
//     else:
//         # note that the zombie has no internal state
//         # so there's nothing to restore other than
//         # the Zombie itself
//         if uid in agent_cache:
//             return agent_cache[uid]
//         else:
//             z = Zombie(uid[0], uid[2])
//             agent_cache[uid] = z
//             return z
// ----

// Additionally, an `agent_cache` dictionary is defined and used when restoring agents: 

// [source,python,numbered]
// ----
// agent_cache = {}
// ----

// This dictionary is the cache of previously created agents. The dictionary keys are the agent unique ids, and the values are the agent instances. The dictionary is used for both Zombie and Human agents.


=== The Model class 

As was demonstrated in the earlier tutorials, the Model class encapsulates the simulation and is responsible for initialization, scheduling events, creating agents and their grid/space environment, and managng logging. In addition, the scheduled events that drive the simulation forward are methods of the Model class.

==== Scheduling Events and Creating the Context

For the Zombies model, the scheduling of events and the creation of the context are similar to the implementations in the <<Tutorial 1 - A Simple Model,Random Walker Model>>. For the Zombies model, both are implemented in the `Model` constructor.

[source,python,numbered]
----
from repast4py import core, space, schedule, logging, random
from repast4py import context as ctx
from repast4py.parameters import create_args_parser, init_params

...

class Model:

    def __init__(self, comm, params):
        self.comm = comm
        self.context = ctx.SharedContext(comm)    #<1>
        self.rank = self.comm.Get_rank()

        self.runner = schedule.init_schedule_runner(comm)    <2>
        self.runner.schedule_repeating_event(1, 1, self.step)    <3>
        self.runner.schedule_stop(params['stop.at'])    <4>
        self.runner.schedule_end_event(self.at_end)     <5>

        ...
    ...
----
<1> Creates a context to hold the agents and the network projection.
<2> Initialize schedule runner.
<3> Schedule the repeating event of `Model.step`, beginning at tick 1 and repeating every tick thereafter.  
<4> Schedule the tick at which the simulation should stop, and events will no longer be executed.
<5> Schedule a simulation end event to occur after events have stopped.

==== Implementing Spatial Projections

After initializing the schedule, adding events, and creating the context to hold the population of agents,
the `Model` constructor creates the two spatial projections, the 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[`SharedGrid`] and the
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[`SharedCSpace`]

Before we create our projections, we first must define a `BoundingBox` equal to the desired size of our space:
[source,python,numbered]
---- 
from repast4py import space

...

class Model:

    def __init__(self, comm, params):
        ... 
        box = space.BoundingBox(0, params['world.width'], 
                                0, params['world.height'], 0, 0)    <1>
        self.grid = space.SharedGrid('grid', bounds=box, borders=BorderType.Sticky, 
                                     occupancy=OccupancyType.Multiple,
                                     buffer_size=2, comm=comm)    <2>
        self.context.add_projection(self.grid)    <3>
        self.space = space.SharedCSpace('space', bounds=box, borders=BorderType.Sticky,
                                        occupancy=OccupancyType.Multiple,
                                        buffer_size=2, comm=comm, 
                                        tree_threshold=100)    <4>
        self.context.add_projection(self.space)    <5>
----
<1> Create a  BoundingBox to initialize the size of the Cartesian spaces. Its
arguments are the minimum x coordinate, the extent of the x dimension, and then the same for
the y and z dimensions. Here we create a 2D box (the z extent is 0) starting at (0,0) and
extending for `params['world.width]` in the x dimension and `params['world.height']` in
the y dimension.
<2> Create the grid projection. `repast4py.space.SharedGrid` takes a name, its bounds, its border, 
and occupancy types, as well as a buffer size, and a MPI communicator as arguments. See the `SharedGrid`
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid[API documentation]
for a description of these arguments. The concept of a buffer was described in the
xref:overview.adoc#_distributed_simulation[Distributed Simulation] section.
<3> Add the grid to the context so that it can be properly synchronized across
processes.
<4> Create the space projection. `repast4py.space.SharedCSpace` takes a name, its bounds, its border, 
and occupancy types, as well as a buffer size, a MPI communicator, and a
tree threshod as arguments. See the `SharedCSpace`
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace[API documentation]
for a description of these arguments.
<5> Add the space to the context so that it can be properly synchronized across
processes.

We use two spatial projections in our Zombies model: a discrete `grid` projection, and a continuous `space` projection. Even though the `space` and `grid` projections are distinct from each other, they are
inialized with the same bounding box. Thus, they are the same size, which allows us to translate between the two projections such that the grid is overlaid on the continuous space. As you have seen, the
grid is used for neighborhood queries, and the continous space for movement.

Within the `Model` class, a `move` method is defined and called by during the movment 
sections of the agents' step methods (<<The Zombie step() Method, `Zombie.step()`>> and <<The Human step() Method, `Human.step()`>>). This `move` method performs the translation and movement on both the
grid and continuous space.

[source,python,numbered]
----
from repast4py.space import ContinuousPoint as cpt
from repast4py.space import DiscretePoint as dpt
...

class Model:

    ...

    def move(self, agent, x, y): #<1>
        self.space.move(agent, cpt(x, y)) #<2>
        self.grid.move(agent, dpt(int(math.floor(x)), int(math.floor(y)))) #<3>

    ...    
----
<1> The `move` method passed the `x` and `y` coodinate on the `space` projection, that the agent
argument is moving to.
<2> Move the agent to the specified point in the continuous space, creating a new ContinuousPoint from
the x and y coordinates. See the `move` 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedCSpace.move[API documentation] for
more details.
<3> Move the agent to the corresponding location in the grid space, by taking the floor of the
x and y coordinates, converting those to ints, creating a DiscretePoint from those ints.
See the `move` 
{website}/apidoc/source/repast4py.space.html#repast4py.space.SharedGrid.move[API documentation] for
more details.

NOTE: The discrete points passed to the discrete grid must be of type integer. (#TODO double check this)

==== Creating the Agents

The population of agents is created within the Model class. First, we obtain the necessary details on our `space` projection the number of processors we are using such that we can assign each agent to a space and a rank. 

[source,python,numbered]
----
local_bounds = self.space.get_local_bounds() #<1>
world_size = comm.Get_size() #<2>
----
<1> The continuous 'space' projection on which to assign a starting location for each of our agents
<2> The total number of process ranks (described earlier in the <<Distributed Simulation>> subsection).

Our Model is seeded with Human agents with the following:

[source,python,numbered]
----
class Model:

    def __init__(self, comm, params):

        ...

        total_human_count = params['human.count'] #<1>
        pp_human_count = int(total_human_count / world_size) #<2>
        if self.rank < total_human_count % world_size: #<3>
            pp_human_count += 1 #<4>

        for i in range(pp_human_count): #<5>
            h = Human(i, self.rank) #<6>
            self.context.add(h) #<7>
            x = random.default_rng.uniform(local_bounds.xmin, local_bounds.xmin + local_bounds.xextent) #<8>
            y = random.default_rng.uniform(local_bounds.ymin, local_bounds.ymin + local_bounds.yextent) #<9>
            self.move(h, x, y) #<10>

        ...

    ...
----
<1> Obtain the number of Human agents from the parameters dictionary.
<2> Compute an average number of Human agents per processor.
<3> Divides the number of humans evenly amongst the set of process ranks (#TODO - improve description here#)
<4> Computes the number of humans to add to the current process rank, based on the total number of human agents, the total number of process ranks, and the current process rank 
<5> Iterate through the number of humans to be assigned to each rank.
<6> Instantiate a human agent at the current rank
<7> Add the new human agent to the context
<8> Choose a random x location within the subspace corresponding to the rank.
<9> Choose a random x location within the subspace corresponding to the rank.
<10> Move the new human agent to the location of `x` and `y` on the continuous `space` 

In a similar manner, we seed our Model with a starting number of Zombie agents:

[source,python,numbered]
----
class Model:

    def __init__(self, comm, params):

        ...

        total_zombie_count = params['zombie.count'] #<1>
        pp_zombie_count = int(total_zombie_count / world_size) #<2>
        if self.rank < total_zombie_count % world_size: #<3>
            pp_zombie_count += 1 #<4>

        for i in range(pp_zombie_count): #<5>
            zo = Zombie(i, self.rank) #<6>
            self.context.add(zo) #<7>
            x = random.default_rng.uniform(local_bounds.xmin, local_bounds.xmin + local_bounds.xextent) #<8>
            y = random.default_rng.uniform(local_bounds.ymin, local_bounds.ymin + local_bounds.yextent) #<9>
            self.move(zo, x, y) #<10>

        self.zombie_id = pp_zombie_count #<11>

    ...
----
<1> Obtain the number of Zombie agents from the parameters dictionary.
<2> Compute an average number of Zombie agents per processor.
<3> Divides the number of zombies evenly amongst the set of process ranks (#TODO - improve description here#)
<4> Computes the number of zombies to add to the current process rank, based on the total number of zombie agents, the total number of process ranks, and the current process rank
<5> Iterate through the number of zombies to be assigned to the current rank
<6> Instantiate a zombie agent at the current rank
<7> Add the new zombie agent to the context
<8> Choose a random x location within the subspace corresponding to the rank.
<9> Choose a random y location within the subspace corresponding to the rank.
<10> Move the new zombie agent to the location of `x` and `y` on the continuous `space` 
<11> The zombie agent is assigned a unique integer that uniquely identifies it on the rank it is initially assigned to

#TODO: Why do we not assign the `human_id` in a similar manner?#

==== Logging

For the Zombies model, we first create a logger to log a dataclass of the agent counts. The logger for our agent counts is declared outside of our Model class as follows:

[source,python,numbered]
----
from dataclasses import dataclass

...

@dataclass
class Counts:
    """Dataclass used by repast4py aggregate logging to record
    the number of Humans and Zombies after each tick.
    """
    humans: int = 0
    zombies: int = 0
----

===== Initializing the logging

We initiate our logger within our Model class with the following:

[source,python,numbered]
----
from repast4py import logging 

...

class Model:

    def __init__(self, comm, params):

        ...

        self.counts = Counts() #<1>
        loggers = logging.create_loggers(self.counts, op=MPI.SUM, rank=self.rank) #<2>
        self.data_set = logging.ReducingDataSet(loggers, MPI.COMM_WORLD, params['counts_file']) #<3>

        ...

    ...
----
<1> Initiates the `Counts()` dataclass object that contains the aggregate counts of the number of Zombie and Human agents
<2> Creates a logger that uses `self.counts` as the source of the data to log. The logger performs a cross process summation (`op=MPI.SUM`) of that data to log.
// and logs the value of the total field in self.meet_log. The names argument specifies the fields to log as a dictionary where the key is the dataclass field to log, and the value is the column header text for that value.
<3> Creates a `logging.ReducingDataSet` from the list of loggers. `params['counts_file']` is the name of the file to log to

//After the logging is initialized, the state of the simulation is logged for the starting tick `0`.

===== The log_counts method

For every tick the `step` method in the Model class is executed, it implements a `log_counts` method, described as follows:

[source,python,numbered]
----
class Model:

    ...

    def log_counts(self, tick): #<1>
        # Get the current number of zombies and humans and log
        counts = self.context.size([Human.TYPE, Zombie.TYPE]) #<2>
        self.counts.humans = counts[Human.TYPE] #<3>
        self.counts.zombies = counts[Zombie.TYPE] #<4>
        self.data_set.log(tick) #<5>

        # Do the cross-rank reduction manually and print the result
        if tick % 10 == 0: #<6>
            human_count = np.zeros(1, dtype='int64') #<7>
            zombie_count = np.zeros(1, dtype='int64') #<8>
            self.comm.Reduce(np.array([self.counts.humans], dtype='int64'), human_count, op=MPI.SUM, root=0) #<9>
            self.comm.Reduce(np.array([self.counts.zombies], dtype='int64'), zombie_count, op=MPI.SUM, root=0) #<10>
            if (self.rank == 0): #<11>
                print("Tick: {}, Human Count: {}, Zombie Count: {}".format(tick, human_count[0], zombie_count[0]),flush=True) #<12>
----
<1> Pass the current simulation tick into the `log_counts` method
<2> Obtains a (#TODO - variable type - dict?#) of the agents within the model context.
<3> Of the agents in `counts`, quantifies the human agents and stores as `self.counts.humans`
<4> Of the agents in `counts`, quantifies the zombie agents and stores as `self.counts.zombies`
<5> Passes the human and zombie agent counts at the given `tick` to the `self.data_set` logger initiated for the <<Initializing the logging,Model class instance>>.
<6> For every `10` ticks, a subroutine is implemented that prints the data to the console (#TODO Is console the correct term here?#).
<7> The `human_count` variable to be printed is initiated as a one-dimensional `numpy` array of a single integer intially set to `0`.
<8> The `zombie_count` variable to be printed is initiated as a one-dimensional `numpy` array of a single integer intially set to `0`.
<9> A cross-process reduce-type (e.g., summation) operation is carried out on the `self.counts.humans` and assigned to the `human_count` array. 
<10> A cross-process reduce-type (e.g., summation) operation is carried out on the `self.counts.zombies` and assigned to the `zombie_count` array. 
<11> (#TODO#)
<12> The `human_count` and `zombie_count` for the given tick are printed to the console.


NOTE: Different from the Walker Model, we log within our step method, rather than as a scheduled event (#TODO Is there a reason for this?#)

==== Scheduled methods

The events for this model are methods defined within the Model class. We schedule events that are executed once as well as repeated. The methods are called according to how they are scheduled, driving the simulation forward. 

===== Step 

The first of our scheduled events is the step method, which is scheduled to execute starting at tick 1 and for every tick thereafter:

[source,python,numbered]
----
class Model:

    ...

    def step(self):
        tick = self.runner.schedule.tick #<1>
        self.log_counts(tick) #<2>
        self.context.synchronize(restore_agent) #<3>

        for z in self.context.agents(Zombie.TYPE): #<4>
            z.step() #<5>

        dead_humans = [] #<6>
        for h in self.context.agents(Human.TYPE): #<7>
            dead, pt = h.step() #<8>
            if dead: #<9>
                dead_humans.append((h, pt)) #<10>

        for h, pt in dead_humans: #<11>
            model.remove_agent(h)
            model.add_zombie(pt)

    ...
----
<1> Defines the current tick value for the corresponding step.
<2> Logs the current values of the `self.log_counts` by calling log on the `self.data_set ReducingDataSet`. The log method takes a floating point argument that specifies the tick at which the data is logged. In this case, we use the current tick value. The `log_counts` method is described below, in <<>>
<3> Synchronizes the state of the simulation across processes using the `restore_agent` function to restore any agents (Zombies and Humans) that have moved processes. See <<Restoring the agents,earlier in this tutorial>> and <<Saving and Restoring Agents>> for more details on this function.
<4> Iterates over all the Zombie agents in the model by obtaining an iterator from the `SharedContext`.
<5> Each Zombie agent then implements one instance of its step function, <<The Zombie step() method,described earlier>>.
<6> An empty list is created to store any humans that have died during this step.
<7> Iterates over all the Human agents in the model by obtaining an iterator from the `SharedContext`.
<8> Each Human agent then implements one instance of its step function, <<The Human step() method,described earlier>>. A boolean variable `dead` is returned along with the location in the `space` projection for each human agent. 
<9> We check if the current human is dead (i.e. the variable `dead` is `True`). 
<10> If the human is dead, we add the human agent `h` to our list of dead humans for this step.
<11> For each newly dead human, we then convert the human agent into a zombie, using the `remove_agent` and `add_zombie` methods described below.

When an infected human is sick for `10` ticks, the human then _dies_ and becomes a Zombie. At the end of the step method, we have a list of humans who are "dead" and must be converted to a Zombie. We implement this process with two methods: first, we remove the human from the context with `remove_agent()`, and second we add a zombie back into the context with `add_zombie()`, both of which are defined in the Model class.

Our `remove_agent()` method is the following:
[source,python,numbered]
----
class Model:

    ...

    def remove_agent(self, agent): #<1>
        self.context.remove(agent) #<2>
----
<1> Method is declared to read in the human agent passed to it.
<2> We remove the human agent from the Model's context, which then ensures it is removed from the corresponding projections and population of agents. 

We then convert the human into a zombie with the `add_zombie()` method, which adds a new Zombie agent at the final location of the newly removed Human:
[source,python,numbered]
----
class Model:

    ...

    def add_zombie(self, pt): #<1>
        z = Zombie(self.zombie_id, self.rank) #<2>
        self.zombie_id += 1 #<3>
        self.context.add(z) #<4>
        self.move(z, pt.x, pt.y) #<5>

    ...
----
<1> The final location of the human agent that just died is passed into the `add_zombie` method
<2> A new Zombie agent is instantiated. 
<3> #TODO#  
<4> We add the newly created zombie to the Model's context
<5> We set the location of the new Zombie agent as the final location of the dead human agent

IMPORTANT: Even though the human agent is no longer within the Model context, the new zombie agent taking the human's place has its own unique agent tuple id. (#TODO - Anything else to add here?#)

===== At End

The final event `self.runner.schedule_end_event(self.at_end)` is scheduled to call `Model.at_end` when the simulation reaches its final tick and ends. This method closes the `data_set` log, ensuring that any remaining unwritten data is written to the output file.
[source,python,numbered]
----
class Model:

    ...

    def at_end(self):
        self.data_set.close()

    ...
----


===== Run 

#TODO - Is `self.runner.execute()` required for a model to run?#

[source,python,numbered]
----
class Model:

    ...

    def run(self):
        self.runner.execute()
----

=== Additional Python Functionality - The numba Package

One of the benefits of implementing Repast4py with the Python language is the numerous scientific libraries available that can be utilized in conjunction with our Repast models. Thus far, we have demonstrated the use of a few different Python libraries, including:

* MPI4py (described in <<Distributed Simulation>>)
* Networkx (see <<Tutorial 2 - The Rumor Network Model,the Rumor Network tutorial>>) 
* Numpy (used in all the tutorials, but notably, `numpy.random` is used for the `repast4py.random` module.
* #TODO - Any other ones we want to point out?#

:cpp: C++

For the Zombies model, we utilize an additional Python library, known as `Numba`. One of the drawbacks of the Python--an _interpreted_ language--is that code runs slower than other languages, specifically, _compiled_ languages, such as {cpp}. Fortunately, there are tools that exist that can allow us to take advantage of both the ease-of-use of interpreted languages such as Python, but the speed and efficiency of compiled languages such as {cpp}. One of these tools that has been developed for Python is the `Numba` library. 

Numba is a _just-in-time_ compiler for Python. It takes small portions of Python code, compiles the subset of code (usually in the form of function blocks), and caches the code so it does not need to be compiled again during the runtime of the program. It is particularly useful for portions of code that are numerically oriented and/or have a lot of loops (i.e. repeated "math" and basic computational processes). 

TIP: The `Numba` library provides a useful https://numba.readthedocs.io/en/stable/user/5minguide.html["5 minute guide to Numba"] overview on their package's webpage. We encourage you to take a look at that page for more information regarding how and why such a package would be useful to implement in your model.   

TIP: If you are using a lot of `Numpy` arrays and functions embedded in loops in your code, functions within your code are likely to benefit from a library such as `Numba`.  

For the Zombies model, we are able to implement Numba to speed up the process of finding our neighborhood of grid locations that our agents must query when looking for humans or zombies. We describe the process of utilizing this package throughout the rest of this section.

==== The Grid Neighbor Finder

Every agent at every tick much search their neighborhood of grid locations to determine which grid location has the most humans or the least zombies. Because this neighborhood of grid locations is dependent on each agent's current location, the neighborhood must be computed _every_ tick for _every_ agent. For our example model instance (described below in <<Running the simulation>>), we run a simulation with `50 ticks` and `8400 agents`. Thus, for this one simulation, we must find this neighborhood of grid locations over `400,000` times. Even just a small computational savings we obtain for one numerical procedure we must repeat this number of times can significantly improve the performance of our simulation.

We implement our `GridNghFinder` as a `class`. In order to utilize Numba for our `GridNghFinder` class, we must first declare the data types of the arguments to be passed to our class. When querying the neighborhood of locations, we use our `grid` projection, which allows us to represent our neighborhood as a set of integer arrays (i.e. a set of nine, `1x1` two-dimensional arrays of integers). Thus, we will pass the list of values that we need to find this neighborhood. The values we pass are defined in the following:

[source,python,numbered]
----
import numba #<1>
from numba import int32, int64 #<2>

...

spec = [  #<3>
    ('mo', int32[:]), #<4>
    ('no', int32[:]), #<5>
    ('xmin', int32),  #<6>
    ('ymin', int32),  #<7>
    ('ymax', int32),  #<8>
    ('xmax', int32)   #<9>
]
----
<1> Import the numba library
<2> Import the types to be used
<3> Declare `spec` to specify the types for the argument to be passed to the Numba class
<4> An array field, `mo`, of 32-bit signed integer types
<5> An array field, `no`, of 32-bit signed integer types
<6> A 32-bit signed integer type scalar field, `xmin`
<7> A 32-bit signed integer type scalar field, `ymin`
<8> A 32-bit signed integer type scalar field, `xmax`
<9> A 32-bit signed integer type scalar field, `ymax`

NOTE: As data type checking in Python is only done when the code is run, the process of declaring the data types for a function's arguments a priori is different than if we were to keep the function strictly as a Python function. 

Our `GridNghFinder` class is then defined as follows:

[source,python,numbered]
----
import numba 
from numba.experimental import jitclass #<1>

...

@jitclass(spec) #<2>
class GridNghFinder:

    def __init__(self, xmin, ymin, xmax, ymax): #<3>
        self.mo = np.array([-1, 0, 1, -1, 0, 1, -1, 0, 1], dtype=np.int32) #<4>
        self.no = np.array([1, 1, 1, 0, 0, 0, -1, -1, -1], dtype=np.int32) #<5>
        self.xmin = xmin  #<6>
        self.ymin = ymin  #<7>
        self.xmax = xmax  #<8>
        self.ymax = ymax  #<9>

    def find(self, x, y): #<10>
        xs = self.mo + x  #<11>
        ys = self.no + y  #<12>

        xd = (xs >= self.xmin) & (xs < self.xmax) #<13>
        xs = xs[xd] #<14>
        ys = ys[xd] #<15>

        yd = (ys >= self.ymin) & (ys < self.ymax) #<16>
        xs = xs[yd] #<17>
        ys = ys[yd] #<18>

        return np.stack((xs, ys, np.zeros(len(ys), dtype=np.int32)), axis=-1) #<19>
----
<1> Numba supports code generation for classes with the `numba.jitclass()` decorator
<2> Declare the `jitclass` passing our variable `spec` that specifies the field types. 
<3> Initialize the variables 
<4> Create an array of relative `x-values` for the neighborhood to be created
<5> Create an array of relative `y-values` for the neighborhood to be created
<6> `xmin = 0` is the minimum horizontal location on the `grid` projection (#TODO Is there an equivalent to `box.xextent` but for the lower limit of `x`?#)
<7> `ymin = 0` is the minimum vertical location on the `grid` projection (#TODO Is there an equivalent to `box.yextent` but for the lower limit of `y`?#)
<8> `xmax` is the maximum horizontal location on the `grid` projection, queried from our Bounding Box `box.xextent`
<9> `ymax` is the maximum vertical location on the `grid` projection, queried from our Bounding Box `box.yextent`
<10> Pass in the center location of our neighborhood (i.e. the current `grid` location of our corresponding agent who is querying the neighborhood)
<11> Compute a new array, `xs` by adding the agent's current `x` position to `mo` (the array of relative `x-values`). `xs` is now an array of all the `x-values` of the agent's neighborhood (regardless of if the x-values are beyond the bounds of our `grid`) 
<12> Compute a new array, `ys` by adding the agent's current `y` position to `no` (the array of relative `y-values`). `ys` is now an array of all the `y-values` of the agent's neighborhood (regardless of if the y-values are beyond the bounds of our `grid`) 
<13> Create `xd`, a Boolean array that specifies the index location of our `xs` array values that are within the Model's `grid` projection boundary (i.e., an array whose values are `FALSE` at the indices corresponding to `xs` values less than `0` and greater than `xmax`, and `TRUE` otherwise)
<14> Reduce `xs` to only values with indices corresponding to `TRUE` values in `xd` 
<15> Reduce `ys` to only values with indices corresponding to `TRUE` values in `xd` 
<16> Create `yd`, a Boolean array that specifies the index location of our `xs` array values that are within the Model's `grid` projection boundary (i.e., an array whose values are `FALSE` at the indices corresponding to `ys` values less than `0` and greater than `ymax`, and `TRUE` otherwise) 
<17> Reduce `xs` to only values with indices corresponding to `TRUE` values in `yd` 
<18> Reduce `ys` to only values with indices corresponding to `TRUE` values in `yd` 
<19> Return the 2-D array of the grid neighborhood within the `grid` projection's bounds for the given agent

(## Not sure how well I explained the above##)
(## Maybe add in an example of the input and output for the class here?##)


=== Running the simulation
An accompanying `YAML` file is where the parameters of the simulation instance of our model are set. For this tutorial's specific instance of the Zombie model, our parameters are set in `zombie_model.yaml` as the following:

[source,yaml,numbered]
----
random.seed: 42
stop.at: 50.0
human.count: 8000
zombie.count: 400
world.width: 200
world.height: 200
run.number: 1
counts_file: './output/agent_counts.csv'
----

An `if name == 'main'` code block is used to parse the input parameters using the `repast4py.parameters` module, and then run the simulation. 

[source,python,numbered]
----
from repast4py.parameters import create_args_parser, init_params

...

if __name__ == "__main__":
    parser = create_args_parser() #<1>
    args = parser.parse_args() #<2>
    params = init_params(args.parameters_file, args.parameters) #<3>
    run(params) #<4>
----
<1> Creates the default command line argument parser.
<2> Parses the command line into its arguments using that default parser
<3> Creates the model input parameters dictionary from those arguments using `parameters.init_params`
<4> Runs the simulation instance

NOTE: The default command line parser created with `parameters.create_args_parser` accepts a path to a YAML format parameters input file. However, a JSON format dictionary string that is provided can override the parameters in the parameters YAML file.

The `run` function creates the Model class and calls its start method, which then begins the simulation by initiating schedule execution. This run function is called in the `if name == 'main'` code block.

[source,python,numbered]
----
from mpi4py import MPI

...

def run(params: Dict):
    """Creates and runs the Zombies Model.

    Args:
        params: the model input parameters
    """
    global model
    model = Model(MPI.COMM_WORLD, params)
    model.run()
----

The Zombies simulation can be run from the command line using the following (#TODO - reformat the following command line such that it is a single line#):

[source,bash,numbered]
----
PYTHONPATH=./src mpirun -n 4 python examples/zombies/zombies.py examples/zombies/zombie_model.yaml
----



